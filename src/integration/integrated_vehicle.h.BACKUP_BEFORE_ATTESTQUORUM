#ifndef MESHCHAIN_INTEGRATED_VEHICLE_H
#define MESHCHAIN_INTEGRATED_VEHICLE_H

#include "../common/types.h"
#include "../common/block.h"
#include "../common/v2x_messages.h"
#include "../common/spatial_index.h"
#include "../crypto/liboqs_wrapper.h"
#include "../crypto/tls13_channel.h"
#include "../crypto/tee_aggregator.h"
#include "../storage/shamir_secret_sharing.h"
#include "../vehicle/witness_selection.h"
#include "../vehicle/block_creator.h"
#include "../infrastructure/rsu.h"
#include "traci_client.h"
#include "wave_stack_omnetpp.h"  // Uses OMNeT++/Veins if available, falls back to wave_stack.h
#include "tof_adapter.h"
#include "libp2p_node.h"
#include "sumo_visualizer.h"

#include <memory>
#include <chrono>
#include <mutex>
#include <atomic>
#include <iomanip>
#include <iostream>
#include <vector>
#include <random>

namespace meshchain {
namespace integration {

/**
 * Integrated Vehicle Node
 *
 * Combines all components for a fully functional Mesh-Chain vehicle:
 * - SUMO mobility (via TraCI)
 * - WAVE V2V/V2I communication (IEEE 802.11p)
 * - ToF distance bounding (UWB or PHY timestamps)
 * - PQC crypto (FALCON, ML-KEM, ML-DSA)
 * - Block creation with witness diversity
 * - Off-chain storage (Shamir Secret Sharing)
 */
class IntegratedVehicle {
public:
    struct Config {
        std::string vehicle_id;

        // TraCI config
        std::shared_ptr<TraCIClient> traci;

        // WAVE config
        WaveStack::Config wave_config;

        // ToF config
        ToFAdapter::Config tof_config;

        // libp2p config
        LibP2PNode::Config libp2p_config;

        // Diversity policy
        vehicle::WitnessSelector::Policy diversity_policy;

        // Crypto
        double sigma_tof_ns;

        // ==================== SIMPLE: Create block when V2X messages arrive ====================
        // ÌÜµÏã† Í∏∞Î°ùÏù¥ ÏûàÏúºÎ©¥ Ï¶âÏãú Î∏îÎ°ù ÏÉùÏÑ±
        // Local finality ‚â§100ms is block creation SPEED

        // Statistics callback
        std::function<void(bool success, double latency_ms)> on_block_created;
    };

private:
    Config config_;
    std::string vehicle_id_;

    // Core components
    std::shared_ptr<TraCIClient> traci_;
    std::shared_ptr<WaveStack> wave_;          // Local V2V (300m)
    std::shared_ptr<ToFAdapter> tof_;
    std::shared_ptr<LibP2PNode> libp2p_;       // Global P2P (internet)

    // Crypto components
    std::shared_ptr<crypto::FalconSigner> signer_;
    std::shared_ptr<crypto::MLKEM> kem_;
    std::shared_ptr<crypto::TLS13Channel> tls_channel_;
    std::shared_ptr<storage::OffChainStorage> off_chain_storage_;

    // Block creation
    std::shared_ptr<vehicle::BlockCreator> block_creator_;

    // TEE Aggregator for block verification
    std::shared_ptr<crypto::TEEAggregator> tee_aggregator_;

    // Timing
    std::chrono::steady_clock::time_point last_cam_time_;
    std::chrono::steady_clock::time_point last_block_time_;

    // Neighboring vehicles cache
    std::map<std::string, WitnessCandidate> neighbor_cache_;

    // Spatial index for fast neighbor queries (300+ vehicle scalability)
    common::SpatialIndex<std::string> spatial_index_;
    mutable std::mutex spatial_index_mutex_;
    std::chrono::steady_clock::time_point last_spatial_rebuild_;
    static constexpr double SPATIAL_REBUILD_INTERVAL_MS = 1000.0;  // Rebuild every 1s

    // Flag: V2X message received, ready to create block
    std::atomic<bool> has_v2x_data_{false};

    // Flag: Block creation in progress (prevent overlapping)
    std::atomic<bool> is_creating_block_{false};

    // Thread safety for witness signing
    mutable std::mutex witness_sign_mutex_;

    // SUMO GUI visualization
    std::shared_ptr<SUMOVisualizer> visualizer_;

    // RSU infrastructure (for L1 Anchoring)
    const std::vector<std::shared_ptr<infrastructure::RSU>>* rsus_;

    // ========== REPUTATION SYSTEM ==========
    // My own reputation score (updated based on block creation success/failure)
    Reputation my_reputation_;

    // Reputation tracking for peer vehicles
    // Maps VehicleID -> Reputation (updated based on witness behavior)
    std::map<VehicleID, Reputation> peer_reputations_;

    // Mutex for thread-safe reputation updates
    mutable std::mutex reputation_mutex_;

    // ========== PUBLIC KEY STORAGE ==========
    // Peer public keys for FALCON signature verification
    // Maps VehicleID -> FALCON-512 public key (897 bytes)
    std::map<VehicleID, std::vector<uint8_t>> peer_public_keys_;

    // Mutex for thread-safe public key access
    mutable std::mutex public_key_mutex_;

    // ========== BLACKLIST SYSTEM ==========
    // Blacklist for malicious vehicles
    std::map<VehicleID, BlacklistEntry> blacklist_;

    // Mutex for thread-safe blacklist access
    mutable std::mutex blacklist_mutex_;

    // ========== MICRO-CHAIN STORAGE ==========
    // Local blockchain (micro-chain) for this vehicle
    std::vector<Block> my_micro_chain_;

    // Mutex for thread-safe chain access
    mutable std::mutex chain_mutex_;

    // Statistics
    size_t total_blocks_created_ = 0;
    size_t total_blocks_failed_ = 0;

    // ========== WITNESS TRACKING SYSTEM ==========
    // Track witness behavior for accountability
    struct WitnessObservation {
        Hash256 block_hash;
        VehicleID block_creator;
        std::set<VehicleID> witnesses_who_signed;       // Witnesses who provided signatures
        std::set<VehicleID> witnesses_who_observed;     // All witnesses who saw the block
        std::set<VehicleID> witnesses_who_reported;     // Witnesses who reported inconsistencies
        Timestamp observation_time;
        bool block_was_malicious;
    };

    // Maps block_hash -> witness observation record
    std::map<Hash256, WitnessObservation> witness_observations_;

    // Mutex for thread-safe witness tracking
    mutable std::mutex witness_tracking_mutex_;

public:
    explicit IntegratedVehicle(const Config& config)
        : config_(config), vehicle_id_(config.vehicle_id), traci_(config.traci) {

        // Initialize WAVE communication
        wave_ = std::make_shared<WaveStack>(config.wave_config, traci_);

        // Initialize ToF adapter
        tof_ = std::make_shared<ToFAdapter>(config.tof_config, traci_);

        // Initialize libp2p node
        libp2p_ = std::make_shared<LibP2PNode>(config.libp2p_config);
        libp2p_->start();

        // Subscribe to mesh-chain topics
        libp2p_->subscribe("meshchain/blocks",
            [this](const LibP2PNode::Message& msg) {
                // Handle received blocks
                std::cout << "[" << vehicle_id_ << "] Received block via libp2p from "
                         << msg.sender.toString() << "\n";

                // Deserialize and verify block
                // In production: Block received_block = deserialize(msg.data);
                // For now: Log receipt only
                // bool valid = verifyReceivedBlock(received_block);
                // if (valid) {
                //     std::cout << "[" << vehicle_id_ << "] ‚úì Block accepted\n";
                // }
            }
        );

        libp2p_->subscribe("meshchain/witnesses",
            [this](const LibP2PNode::Message& msg) {
                // Handle witness advertisements
            }
        );

        // Announce self as potential witness
        libp2p_->provideToDHT("witnesses:region");

        // Initialize PQC signer (FALCON-512)
        signer_ = std::make_shared<crypto::FalconSigner>();
        signer_->generateKeys();

        // Initialize ML-KEM for key exchange
        kem_ = std::make_shared<crypto::MLKEM>();
        kem_->generateKeys();

        // Initialize TLS 1.3 channel
        tls_channel_ = std::make_shared<crypto::TLS13Channel>(vehicle_id_);

        // Initialize SUMO visualizer
        visualizer_ = std::make_shared<SUMOVisualizer>(true);  // Enabled by default

        // Initialize off-chain storage
        storage::OffChainStorage::StorageConfig storage_config;
        storage_config.threshold = 3;
        storage_config.total_shares = 5;
        storage_config.tier = "hot";
        off_chain_storage_ = std::make_shared<storage::OffChainStorage>(storage_config);

        // Initialize block creator
        vehicle::BlockCreator::Config creator_config;
        creator_config.vehicle_id = vehicle_id_;
        creator_config.signer = signer_;
        creator_config.tof = tof_->getToFMeasurement();  // Get ToFMeasurement from adapter
        creator_config.tls_channel = tls_channel_;
        creator_config.off_chain_storage = off_chain_storage_;
        creator_config.diversity_policy = config.diversity_policy;
        creator_config.sigma_tof_ns = config.sigma_tof_ns;
        creator_config.visualizer = visualizer_;  // Pass visualizer

        // CRITICAL: Bind reputation callbacks
        // BlockCreator needs access to reputation system for:
        // 1. Including creator's reputation in block header
        // 2. Updating witness reputations after signature attempts
        creator_config.get_creator_reputation = [this]() {
            return this->getMyReputation();
        };
        creator_config.update_witness_reputation = [this](const VehicleID& witness_id, bool success) {
            this->recordPeerInteraction(witness_id, success);
        };

        block_creator_ = std::make_shared<vehicle::BlockCreator>(creator_config);

        // Initialize TEE aggregator for block verification
        crypto::TEEAggregator::Config tee_config;
        tee_config.enable_individual_verification = true;
        tee_config.max_aggregation_time_ms = 10.0;
        tee_aggregator_ = std::make_shared<crypto::TEEAggregator>(tee_config);

        // Register WAVE message handlers
        setupMessageHandlers();

        // Initialize timing
        last_cam_time_ = std::chrono::steady_clock::now();
        last_block_time_ = std::chrono::steady_clock::now();
        last_spatial_rebuild_ = std::chrono::steady_clock::now();

        // ========== RANDOM INITIAL REPUTATION ==========
        // Initialize with random reputation [0.3, 0.8] to ensure diversity
        // Range: 0.5 ensures ‚â•0.3 difference is achievable
        // Start above MIN_REPUTATION (0.2) and min_reputation threshold (0.3)
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> dis(0.3, 0.8);
        my_reputation_.R = dis(gen);
        std::cout << "[" << vehicle_id_ << "] Initialized with reputation R="
                  << std::fixed << std::setprecision(3) << my_reputation_.R << "\n";
    }

    /**
     * Main simulation step
     * Called at every simulation time step
     *
     * @param all_vehicles Map of all vehicles (for witness signing)
     */
    void step(const std::map<std::string, std::shared_ptr<IntegratedVehicle>>& all_vehicles) {
        auto now = std::chrono::steady_clock::now();

        // 1. Broadcast CAM periodically (every 100ms)
        auto cam_elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            now - last_cam_time_).count();

        if (cam_elapsed >= config_.wave_config.cam_interval_ms) {
            wave_->broadcastCAM(my_reputation_.R);
            last_cam_time_ = now;
        }

        // 2. Process received WAVE messages
        wave_->processReceivedMessages();

        // 3. Update neighbor cache from received CAMs
        updateNeighborCache();

        // 4. SIMPLE: V2X ÌÜµÏã† Í∏∞Î°ù ÏûàÏúºÎ©¥ Ï¶âÏãú Î∏îÎ°ù ÏÉùÏÑ±
        // CRITICAL: Î∏îÎ°ù ÏÉùÏÑ± Ï§ëÎ≥µ Î∞©ÏßÄ (Î©îÎ™®Î¶¨ ÏÜêÏÉÅ Î∞©ÏßÄ)
        if (has_v2x_data_.load() && !is_creating_block_.load()) {
            // Atomic CAS (Compare-And-Swap) to prevent race
            bool expected = false;
            if (is_creating_block_.compare_exchange_strong(expected, true)) {
                std::cout << "[" << vehicle_id_ << "] üì¶ V2X data received ‚Üí Creating block\n";

                tryCreateBlock(all_vehicles);

                has_v2x_data_.store(false);  // Reset flag
                is_creating_block_.store(false);  // Release lock
                last_block_time_ = now;
            }
        }
    }

    /**
     * Process WAVE message propagation
     * Must be called after all vehicles have enqueued their messages
     */
    void processMessagePropagation(std::map<std::string, std::shared_ptr<WaveStack>>& all_stacks) {
        wave_->simulateMessagePropagation(all_stacks);
    }

    /**
     * Get WAVE stack for message propagation
     */
    std::shared_ptr<WaveStack> getWaveStack() {
        return wave_;
    }

    /**
     * Get vehicle ID
     */
    std::string getVehicleId() const {
        return vehicle_id_;
    }

    /**
     * Get my FALCON-512 public key
     */
    std::vector<uint8_t> getMyPublicKey() const {
        return signer_->getPublicKey();
    }

    /**
     * Register a peer's FALCON-512 public key
     * Used for verifying signatures from that peer
     */
    void registerPeerPublicKey(const VehicleID& peer_id, const std::vector<uint8_t>& public_key) {
        std::lock_guard<std::mutex> lock(public_key_mutex_);
        peer_public_keys_[peer_id] = public_key;
    }

    /**
     * Verify FALCON-512 signature on data
     * @param peer_id ID of the signing vehicle
     * @param data Data that was signed
     * @param signature FALCON-512 signature
     * @return true if signature is valid, false otherwise
     */
    bool verifyPeerSignature(const VehicleID& peer_id,
                            const std::vector<uint8_t>& data,
                            const std::vector<uint8_t>& signature) const {
        // Get peer's public key
        std::vector<uint8_t> public_key;
        {
            std::lock_guard<std::mutex> lock(public_key_mutex_);
            auto it = peer_public_keys_.find(peer_id);
            if (it == peer_public_keys_.end()) {
                std::cout << "  [verifyPeerSignature] No public key for " << peer_id << "\n";
                return false;
            }
            public_key = it->second;
        }

        // Verify signature using FALCON-512
        bool valid = signer_->verify(data, signature, public_key);

        return valid;
    }

    /**
     * Record witness observation for a block
     * Called when a block is created or received
     */
    void recordWitnessObservation(const Block& block) {
        std::lock_guard<std::mutex> lock(witness_tracking_mutex_);

        WitnessObservation obs;
        obs.block_hash = block.block_hash;
        obs.block_creator = std::string(block.header.creator_pk.begin(),
                                       block.header.creator_pk.begin() +
                                       std::min(size_t(32), block.header.creator_pk.size()));
        obs.observation_time = std::chrono::system_clock::now();
        obs.block_was_malicious = false;  // Will be updated if maliciousness is detected

        // Extract witnesses who signed from block header
        // In a real implementation, we would parse witness IDs from witness_set_commit
        // For now, we track based on witness_sigs count
        for (size_t i = 0; i < block.header.witness_sigs.size(); ++i) {
            // Would extract actual witness ID here
            std::string witness_id = "witness_" + std::to_string(i);
            obs.witnesses_who_signed.insert(witness_id);
        }

        witness_observations_[block.block_hash] = obs;
    }

    /**
     * Record that a witness observed a block (even if didn't sign)
     * Called when witness sees block via gossip
     */
    void recordWitnessSeenBlock(const Hash256& block_hash, const VehicleID& witness_id) {
        std::lock_guard<std::mutex> lock(witness_tracking_mutex_);

        auto it = witness_observations_.find(block_hash);
        if (it != witness_observations_.end()) {
            it->second.witnesses_who_observed.insert(witness_id);
        }
    }

    /**
     * Record that a witness reported an inconsistency
     */
    void recordWitnessReport(const Hash256& block_hash, const VehicleID& witness_id) {
        std::lock_guard<std::mutex> lock(witness_tracking_mutex_);

        auto it = witness_observations_.find(block_hash);
        if (it != witness_observations_.end()) {
            it->second.witnesses_who_reported.insert(witness_id);
        }
    }

    /**
     * Mark a block as malicious and identify silent witnesses
     * Returns list of witnesses who saw the block but didn't report
     */
    std::vector<VehicleID> markBlockMaliciousAndGetSilentWitnesses(const Hash256& block_hash) {
        std::lock_guard<std::mutex> lock(witness_tracking_mutex_);

        std::vector<VehicleID> silent_witnesses;

        auto it = witness_observations_.find(block_hash);
        if (it != witness_observations_.end()) {
            it->second.block_was_malicious = true;

            // Find witnesses who observed but didn't report
            for (const auto& witness : it->second.witnesses_who_observed) {
                if (it->second.witnesses_who_reported.find(witness) ==
                    it->second.witnesses_who_reported.end()) {
                    silent_witnesses.push_back(witness);
                }
            }
        }

        return silent_witnesses;
    }

    /**
     * Get witness tracking statistics for a block
     */
    struct WitnessStats {
        size_t total_signed;
        size_t total_observed;
        size_t total_reported;
        size_t silent_count;
        bool was_malicious;
    };

    WitnessStats getWitnessStats(const Hash256& block_hash) const {
        std::lock_guard<std::mutex> lock(witness_tracking_mutex_);

        WitnessStats stats = {0, 0, 0, 0, false};

        auto it = witness_observations_.find(block_hash);
        if (it != witness_observations_.end()) {
            stats.total_signed = it->second.witnesses_who_signed.size();
            stats.total_observed = it->second.witnesses_who_observed.size();
            stats.total_reported = it->second.witnesses_who_reported.size();
            stats.was_malicious = it->second.block_was_malicious;

            // Silent = observed but didn't report
            for (const auto& witness : it->second.witnesses_who_observed) {
                if (it->second.witnesses_who_reported.find(witness) ==
                    it->second.witnesses_who_reported.end()) {
                    stats.silent_count++;
                }
            }
        }

        return stats;
    }

    /**
     * Set RSU infrastructure pointer
     */
    void setRSUs(const std::vector<std::shared_ptr<infrastructure::RSU>>* rsus) {
        rsus_ = rsus;
    }

    /**
     * L1 Anchoring: Handle RSU's request for unanchored blocks (pull-based)
     * @param requesting_rsu RSU that is requesting blocks
     * @param last_anchor_time Timestamp of RSU's last anchor (to avoid duplicates)
     */
    void onAnchorRequest(infrastructure::RSU* requesting_rsu, Timestamp last_anchor_time) {
        std::lock_guard<std::mutex> lock(chain_mutex_);

        // Get my position
        auto my_state = traci_->getVehicleState(vehicle_id_);
        if (!my_state.has_value()) {
            return;
        }

        double my_x = my_state->x;
        double my_y = my_state->y;
        double distance = requesting_rsu->calculateDistance(my_x, my_y);

        // Only respond if in range
        if (!requesting_rsu->isInRange(my_x, my_y)) {
            return;
        }

        // Find unanchored LOCALLY_FINAL blocks
        std::vector<Block> unanchored_blocks;

        for (const auto& block : my_micro_chain_) {
            // Only send LOCALLY_FINAL blocks created after last anchor
            if (block.header.state == BlockState::LOCALLY_FINAL &&
                block.received_at > last_anchor_time &&
                !requesting_rsu->isBlockAnchored(block.block_hash)) {
                unanchored_blocks.push_back(block);
            }
        }

        // Send blocks to RSU
        if (!unanchored_blocks.empty()) {

            for (const auto& block : unanchored_blocks) {
                requesting_rsu->receiveBlock(block, vehicle_id_, distance);
            }
        }
    }

    /**
     * Act as witness: sign block as witness
     * Called by other vehicles when they want this vehicle to witness their block
     * Thread-safe: Multiple creators can request signatures from same witness in parallel
     */
    std::vector<uint8_t> signAsWitness(const std::vector<uint8_t>& data_to_sign) {
        // CRITICAL: Protect FALCON signer from concurrent access
        // Multiple vehicles may select this vehicle as witness simultaneously
        std::lock_guard<std::mutex> lock(witness_sign_mutex_);
        return signer_->sign(data_to_sign);
    }

    /**
     * Get signer for witness role
     */
    std::shared_ptr<crypto::FalconSigner> getSigner() {
        return signer_;
    }

    /**
     * Perform TLS 1.3 server handshake (witness side)
     * Called by creator when they want to establish TLS session
     * Thread-safe: Protected by TLS13Channel's internal state
     */
    std::vector<uint8_t> performTLSServerHandshake(
            const std::vector<uint8_t>& client_key_share,
            const std::vector<uint8_t>& client_hello_data) {
        return tls_channel_->performServerHandshake(client_key_share, client_hello_data);
    }

    /**
     * Decrypt TLS 1.3 application data (witness side)
     * Called after handshake to decrypt signature requests
     */
    std::vector<uint8_t> decryptTLSApplicationData(
            const std::vector<uint8_t>& encrypted_data) {
        return tls_channel_->decryptApplicationData(encrypted_data);
    }

    /**
     * Get statistics
     */
    void getStatistics(size_t& msgs_sent, size_t& msgs_received, size_t& msgs_lost) const {
        wave_->getStatistics(msgs_sent, msgs_received, msgs_lost);
    }

    // ========== REPUTATION MANAGEMENT ==========

    /**
     * Get my reputation score
     */
    Reputation getMyReputation() const {
        std::lock_guard<std::mutex> lock(reputation_mutex_);
        return my_reputation_;
    }

    /**
     * Update my reputation based on action outcome
     * @param valid True if action was successful, false if failed
     */
    void updateMyReputation(bool valid) {
        std::lock_guard<std::mutex> lock(reputation_mutex_);
        my_reputation_.update(valid);
        std::cout << "[" << vehicle_id_ << "] My reputation updated: R="
                  << my_reputation_.R << " (" << (valid ? "SUCCESS" : "FAILURE")
                  << ", " << my_reputation_.valid_interactions << "/"
                  << my_reputation_.total_interactions << ")\n";
    }

    /**
     * Get reputation of a peer vehicle
     * @param peer_id Peer vehicle ID
     * @return Reputation or default (0.5) if not tracked yet
     */
    Reputation getPeerReputation(const VehicleID& peer_id) const {
        std::lock_guard<std::mutex> lock(reputation_mutex_);
        auto it = peer_reputations_.find(peer_id);
        if (it != peer_reputations_.end()) {
            return it->second;
        }
        return Reputation();  // Default: R=0.5
    }

    /**
     * Record interaction with a peer and update their reputation
     * @param peer_id Peer vehicle ID
     * @param valid True if interaction was successful, false if failed
     */
    void recordPeerInteraction(const VehicleID& peer_id, bool valid) {
        std::lock_guard<std::mutex> lock(reputation_mutex_);
        peer_reputations_[peer_id].update(valid);

        // Log only failures and every 10th success (reduce noise)
        if (!valid || peer_reputations_[peer_id].total_interactions % 10 == 0) {
            std::cout << "[" << vehicle_id_ << "] Peer " << peer_id
                      << " reputation updated: R=" << peer_reputations_[peer_id].R
                      << " (" << (valid ? "SUCCESS" : "FAILURE") << ")\n";
        }
    }

    // ========== BLACKLIST MANAGEMENT ==========

    /**
     * Check if a vehicle is blacklisted
     * @param vehicle_id Vehicle to check
     * @return True if blacklisted and still active
     */
    bool isBlacklisted(const VehicleID& vehicle_id) const {
        std::lock_guard<std::mutex> lock(blacklist_mutex_);

        auto it = blacklist_.find(vehicle_id);
        if (it == blacklist_.end()) {
            return false;
        }

        return it->second.isActive();
    }

    /**
     * Add vehicle to blacklist
     * @param vehicle_id Vehicle to blacklist
     * @param reason Reason for blacklisting
     * @param severity Severity score (0.0 ~ 1.0)
     * @param duration_sec Duration in seconds
     */
    void addToBlacklist(const VehicleID& vehicle_id, const std::string& reason,
                       double severity, int duration_sec = BLACKLIST_DURATION_SECONDS) {
        std::lock_guard<std::mutex> lock(blacklist_mutex_);

        BlacklistEntry entry(vehicle_id, reason, severity, duration_sec);
        blacklist_[vehicle_id] = entry;

        std::cout << "[" << vehicle_id_ << "] BLACKLISTED: " << vehicle_id
                  << " | Reason: " << reason
                  << " | Severity: " << severity
                  << " | Duration: " << duration_sec << "s\n";
    }

    /**
     * Clean up expired blacklist entries
     */
    void cleanupBlacklist() {
        std::lock_guard<std::mutex> lock(blacklist_mutex_);

        auto it = blacklist_.begin();
        while (it != blacklist_.end()) {
            if (!it->second.isActive()) {
                std::cout << "[" << vehicle_id_ << "] Blacklist expired: " << it->first << "\n";
                it = blacklist_.erase(it);
            } else {
                ++it;
            }
        }
    }

    /**
     * Apply malicious penalty to a vehicle and potentially blacklist
     * @param vehicle_id Vehicle that committed malicious act
     * @param penalty Penalty amount
     * @param reason Reason for penalty
     */
    void applyMaliciousPenalty(const VehicleID& vehicle_id, double penalty,
                               const std::string& reason) {
        std::lock_guard<std::mutex> lock(reputation_mutex_);

        peer_reputations_[vehicle_id].applyMaliciousPenalty(penalty);

        std::cout << "[" << vehicle_id_ << "] Malicious penalty applied to " << vehicle_id
                  << " | Penalty: -" << penalty
                  << " | New R: " << peer_reputations_[vehicle_id].R
                  << " | Reason: " << reason << "\n";

        // Check if reputation dropped below blacklist threshold
        if (peer_reputations_[vehicle_id].R < BLACKLIST_THRESHOLD) {
            double severity = 1.0 - peer_reputations_[vehicle_id].R;  // Lower R = higher severity
            addToBlacklist(vehicle_id, reason, severity);
        }
    }

    /**
     * Reward witness for accurate reporting
     * @param vehicle_id Vehicle that made accurate report
     * @param reward Reward amount
     */
    void applyReportReward(const VehicleID& vehicle_id, double reward) {
        std::lock_guard<std::mutex> lock(reputation_mutex_);

        peer_reputations_[vehicle_id].applyReportReward(reward);

        std::cout << "[" << vehicle_id_ << "] Report reward applied to " << vehicle_id
                  << " | Reward: +" << reward
                  << " | New R: " << peer_reputations_[vehicle_id].R << "\n";
    }

    // ========== INCONSISTENCY DETECTION ==========

    /**
     * Calculate witness weight based on reputation
     * Higher reputation = higher weight in voting
     */
    double calculateWitnessWeight(double reputation) const {
        // Sigmoid transformation: w = 1 / (1 + e^(-10*(R-0.5)))
        // This gives:
        // R=0.3 ‚Üí w‚âà0.05 (very low weight)
        // R=0.5 ‚Üí w=0.5  (neutral)
        // R=0.7 ‚Üí w‚âà0.95 (high weight)
        return 1.0 / (1.0 + std::exp(-10.0 * (reputation - 0.5)));
    }

    /**
     * Process inconsistency reports from witnesses
     * @param reports List of inconsistency reports
     * @param block_creator_id ID of the accused block creator
     * @return True if block is deemed malicious
     */
    bool processInconsistencyReports(
        const std::vector<InconsistencyReport>& reports,
        const VehicleID& block_creator_id)
    {
        if (reports.empty()) {
            return false;  // No reports, assume benign
        }

        std::cout << "[" << vehicle_id_ << "] Processing " << reports.size()
                  << " inconsistency reports for block creator " << block_creator_id << "\n";

        // Step 1: Filter valid reports (signature check + minimum reputation)
        std::vector<InconsistencyReport> valid_reports;
        for (const auto& report : reports) {
            // Get reporter's reputation
            double reporter_rep = 0.5;  // Default
            {
                std::lock_guard<std::mutex> lock(reputation_mutex_);
                auto it = peer_reputations_.find(report.reporter_id);
                if (it != peer_reputations_.end()) {
                    reporter_rep = it->second.R;
                }
            }

            // Check minimum reputation threshold
            if (reporter_rep >= WITNESS_CONFIDENCE_MIN) {
                // Verify FALCON-512 signature on report
                std::vector<uint8_t> data_to_verify = report.getDataToSign();
                bool signature_valid = verifyPeerSignature(
                    report.reporter_id,
                    data_to_verify,
                    report.signature
                );

                if (signature_valid) {
                    valid_reports.push_back(report);
                } else {
                    std::cout << "  [processInconsistencyReports] Invalid FALCON signature from "
                              << report.reporter_id << " - rejecting report\n";

                    // Penalize reporter for invalid signature (possible forgery attempt)
                    recordPeerInteraction(report.reporter_id, false);
                }
            } else {
                std::cout << "  [processInconsistencyReports] Rejected report from "
                          << report.reporter_id << " (R=" << reporter_rep
                          << " < " << WITNESS_CONFIDENCE_MIN << ")\n";
            }
        }

        if (valid_reports.empty()) {
            std::cout << "  [processInconsistencyReports] No valid reports\n";
            return false;
        }

        // Step 2: Calculate weighted votes
        double weighted_votes = 0.0;
        double total_weight = 0.0;

        for (const auto& report : valid_reports) {
            double reporter_rep = 0.5;
            {
                std::lock_guard<std::mutex> lock(reputation_mutex_);
                auto it = peer_reputations_.find(report.reporter_id);
                if (it != peer_reputations_.end()) {
                    reporter_rep = it->second.R;
                }
            }

            double weight = calculateWitnessWeight(reporter_rep);
            weighted_votes += weight * report.inconsistency_score;
            total_weight += weight;

            std::cout << "  Report from " << report.reporter_id
                      << " | R=" << reporter_rep
                      << " | weight=" << weight
                      << " | inconsistency=" << report.inconsistency_score << "\n";
        }

        double avg_inconsistency = weighted_votes / total_weight;

        std::cout << "  Weighted average inconsistency: " << avg_inconsistency
                  << " (threshold: " << INCONSISTENCY_THRESHOLD << ")\n";

        // Step 3: Make decision
        bool is_malicious = (avg_inconsistency >= INCONSISTENCY_THRESHOLD);

        if (is_malicious) {
            std::cout << "  ‚ö†Ô∏è  MALICIOUS BLOCK DETECTED!\n";

            // Step 4a: Apply penalty to block creator
            double penalty = MALICIOUS_PENALTY_BASE * avg_inconsistency;
            penalty = std::min(penalty, MALICIOUS_PENALTY_MAX);
            applyMaliciousPenalty(block_creator_id, penalty,
                                 "Inconsistent block content (avg_score=" +
                                 std::to_string(avg_inconsistency) + ")");

            // Step 4b: Reward accurate reporters
            for (const auto& report : valid_reports) {
                if (report.inconsistency_score >= INCONSISTENCY_THRESHOLD) {
                    applyReportReward(report.reporter_id, ACCURATE_REPORT_REWARD);

                    // Record that this witness reported the issue
                    recordWitnessReport(report.block_hash, report.reporter_id);
                }
            }

            // Step 4c: Penalize witnesses who didn't report (silent witnesses)
            if (!valid_reports.empty()) {
                Hash256 block_hash = valid_reports[0].block_hash;

                // Mark block as malicious and get list of silent witnesses
                std::vector<VehicleID> silent_witnesses =
                    markBlockMaliciousAndGetSilentWitnesses(block_hash);

                if (!silent_witnesses.empty()) {
                    std::cout << "  ‚ö†Ô∏è  Found " << silent_witnesses.size()
                              << " silent witnesses (observed but didn't report)\n";

                    // Apply penalty to silent witnesses for failing to report malicious behavior
                    const double SILENT_WITNESS_PENALTY = 0.02;
                    for (const auto& silent_witness : silent_witnesses) {
                        std::cout << "    Penalizing silent witness: " << silent_witness << "\n";
                        recordPeerInteraction(silent_witness, false);

                        // Apply additional penalty for negligence
                        {
                            std::lock_guard<std::mutex> lock(reputation_mutex_);
                            auto it = peer_reputations_.find(silent_witness);
                            if (it != peer_reputations_.end()) {
                                it->second.R = std::max(MIN_REPUTATION,
                                                       it->second.R - SILENT_WITNESS_PENALTY);
                            }
                        }
                    }
                }
            }

        } else {
            std::cout << "  ‚úì Block deemed benign\n";

            // Optionally penalize false reporters
            // (Skip for now to avoid punishing legitimate concerns)
        }

        return is_malicious;
    }

    // ========== MICRO-CHAIN QUERY METHODS ==========

    /**
     * Get the current length of this vehicle's micro-chain
     */
    size_t getMicroChainLength() const {
        std::lock_guard<std::mutex> lock(chain_mutex_);
        return my_micro_chain_.size();
    }

    /**
     * Get total blocks created (including failed attempts)
     */
    void getBlockStatistics(size_t& created, size_t& failed) const {
        std::lock_guard<std::mutex> lock(chain_mutex_);
        created = total_blocks_created_;
        failed = total_blocks_failed_;
    }

    /**
     * Get a copy of the entire micro-chain
     */
    std::vector<Block> getMicroChain() const {
        std::lock_guard<std::mutex> lock(chain_mutex_);
        return my_micro_chain_;
    }

    /**
     * Print micro-chain summary to console
     */
    void printMicroChainSummary() const {
        std::lock_guard<std::mutex> lock(chain_mutex_);

        std::cout << "\n========== Micro-Chain Summary for " << vehicle_id_ << " ==========\n";
        std::cout << "Total blocks in chain: " << my_micro_chain_.size() << "\n";
        std::cout << "Blocks created: " << total_blocks_created_ << "\n";
        std::cout << "Blocks failed: " << total_blocks_failed_ << "\n";
        std::cout << "Success rate: " << std::fixed << std::setprecision(1)
                  << (total_blocks_created_ + total_blocks_failed_ > 0
                      ? (100.0 * total_blocks_created_ / (total_blocks_created_ + total_blocks_failed_))
                      : 0.0) << "%\n";

        if (!my_micro_chain_.empty()) {
            std::cout << "\nRecent blocks (last " << std::min<size_t>(5, my_micro_chain_.size()) << "):\n";
            size_t start = my_micro_chain_.size() > 5 ? my_micro_chain_.size() - 5 : 0;

            // Get reference time from first block
            auto ref_time = my_micro_chain_[0].header.time;

            for (size_t i = start; i < my_micro_chain_.size(); i++) {
                const auto& block = my_micro_chain_[i];

                // Calculate relative time from first block
                auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
                    block.header.time - ref_time).count() / 1000.0;

                std::cout << "  Block #" << i << ": "
                          << "witnesses=" << block.header.witness_sigs.size()
                          << ", elapsed=" << std::fixed << std::setprecision(1) << elapsed << "s"
                          << ", hash=" << hashToString(block.block_hash).substr(0, 8) << "...\n";
            }
        }
        std::cout << "============================================================\n\n";
    }

private:
    /**
     * Rebuild spatial index from current neighbor cache
     * Called periodically (every 1s) to optimize witness selection
     */
    void rebuildSpatialIndex() {
        std::lock_guard<std::mutex> lock(spatial_index_mutex_);

        // Get my current position
        if (!traci_) return;

        auto my_state_opt = traci_->getVehicleState(vehicle_id_);
        if (!my_state_opt.has_value()) return;

        // Build point cloud from neighbor cache
        std::vector<common::SpatialIndex<std::string>::Point3D> points;
        for (const auto& [neighbor_id, candidate] : neighbor_cache_) {
            auto neighbor_state_opt = traci_->getVehicleState(neighbor_id);
            if (neighbor_state_opt.has_value()) {
                const auto& state = *neighbor_state_opt;
                points.emplace_back(state.x, state.y, state.z, neighbor_id);
            }
        }

        // Rebuild index
        spatial_index_.build(points);
    }

    /**
     * Remove stale neighbors (not seen in 5 seconds)
     * Prevents memory bloat in high-density scenarios
     */
    void cleanupStaleNeighbors() {
        auto now = std::chrono::system_clock::now();
        constexpr double STALE_THRESHOLD_S = 5.0;

        std::vector<std::string> to_remove;
        for (const auto& [neighbor_id, candidate] : neighbor_cache_) {
            auto age = std::chrono::duration<double>(now - candidate.first_contact).count();
            if (age > STALE_THRESHOLD_S) {
                to_remove.push_back(neighbor_id);
            }
        }

        for (const auto& id : to_remove) {
            neighbor_cache_.erase(id);
        }

        if (!to_remove.empty()) {
            std::cout << "[" << vehicle_id_ << "] Cleaned up " << to_remove.size()
                     << " stale neighbors (cache size now: " << neighbor_cache_.size() << ")\n";
        }
    }

    /**
     * Get nearby neighbors using spatial index (fast for 300+ vehicles)
     * @param max_count Maximum number of neighbors to return
     * @return Witness candidates sorted by distance
     */
    std::vector<WitnessCandidate> getNearbyNeighbors(size_t max_count) {
        std::lock_guard<std::mutex> lock(spatial_index_mutex_);

        if (!traci_) return {};

        auto my_state_opt = traci_->getVehicleState(vehicle_id_);
        if (!my_state_opt.has_value()) return {};

        const auto& my_state = *my_state_opt;
        common::SpatialIndex<std::string>::Point3D query(my_state.x, my_state.y, my_state.z, vehicle_id_);

        // Use k-NN query for efficiency
        auto nearby_points = spatial_index_.kNearestNeighbors(query, max_count);

        // Convert to WitnessCandidates
        std::vector<WitnessCandidate> candidates;
        for (const auto& point : nearby_points) {
            auto it = neighbor_cache_.find(point.data);
            if (it != neighbor_cache_.end()) {
                candidates.push_back(it->second);
            }
        }

        return candidates;
    }

    /**
     * Setup WAVE message handlers
     */
    void setupMessageHandlers() {
        // Handle received CAMs - update neighbor knowledge
        wave_->registerCallback(WaveStack::MessageType::CAM,
            [this](const WaveStack::WaveMessage& msg) {
                // Debug: count CAM callbacks
                static size_t cam_callback_count = 0;
                cam_callback_count++;

                if (!msg.cam.has_value()) {
                    std::cout << "[" << vehicle_id_ << "] ‚ö† WARNING: CAM callback invoked but msg.cam is empty!\n";
                    return;
                }

                const CAM& cam = *msg.cam;

                // Debug: log every 100th CAM (to avoid flooding)
                if (cam_callback_count % 100 == 1) {
                    std::cout << "[" << vehicle_id_ << "] Processing CAM from " << cam.sender_id
                             << " (callback #" << cam_callback_count << ")\n";
                }

                // Create/update witness candidate from CAM
                WitnessCandidate candidate;
                candidate.id = cam.sender_id;
                candidate.public_key = std::vector<uint8_t>(897, 0xAB);  // Would get from CAM
                candidate.kem_public_key = std::vector<uint8_t>(1184, 0xCD);  // Would get from CAM

                // CRITICAL: Use sender's actual reputation from CAM message
                // This ensures we use the sender's initialized reputation value
                Reputation rep;
                rep.R = cam.sender_reputation;
                candidate.reputation = rep;

                // Assign realistic OEM based on vehicle ID (20 major manufacturers)
                // Use hash-based assignment with additional mixing for better distribution
                static const std::vector<std::string> oems = {
                    "Toyota", "Honda", "Ford", "GM", "Tesla",
                    "BMW", "Mercedes-Benz", "Volkswagen", "Audi", "Hyundai",
                    "Kia", "Nissan", "Mazda", "Subaru", "Volvo",
                    "Porsche", "Lexus", "Acura", "Chevrolet", "Dodge"
                };
                // Use full string hash with better mixing to avoid collisions
                std::string id_str = cam.sender_id;
                size_t id_hash = std::hash<std::string>{}(id_str);

                // Additional mixing: XOR with length and reverse hash
                std::string id_rev(id_str.rbegin(), id_str.rend());
                size_t rev_hash = std::hash<std::string>{}(id_rev);
                size_t mixed_hash = id_hash ^ (rev_hash << 1) ^ (id_str.length() * 0x9e3779b9);

                size_t oem_index = mixed_hash % oems.size();
                candidate.oem = oems[oem_index];

                // Get actual distance from SUMO (if available)
                if (traci_) {
                    auto distance_opt = traci_->getDistance(vehicle_id_, cam.sender_id);
                    if (distance_opt.has_value()) {
                        candidate.distance_m = *distance_opt;
                    }
                } else {
                    // Sim mode: use approximate distance from CAM position
                    candidate.distance_m = 50.0 + (std::hash<std::string>{}(cam.sender_id) % 200);
                }

                candidate.first_contact = msg.received_at;

                neighbor_cache_[cam.sender_id] = candidate;

                // V2X ÌÜµÏã† Í∏∞Î°ù Î∞õÏùå ‚Üí Î∏îÎ°ù ÏÉùÏÑ± ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï (atomic)
                has_v2x_data_.store(true);

                // Debug: log neighbor cache size every 100th CAM
                if (cam_callback_count % 100 == 1) {
                    std::cout << "[" << vehicle_id_ << "] neighbor_cache_ size: "
                             << neighbor_cache_.size() << "\n";
                }
            }
        );

        // Handle received DENMs - forward to application
        wave_->registerCallback(WaveStack::MessageType::DENM,
            [this](const WaveStack::WaveMessage& msg) {
                if (!msg.denm.has_value()) return;

                const DENM& denm = *msg.denm;
                std::cout << "[" << vehicle_id_ << "] üö® DENM received from "
                         << msg.sender_id << ": " << static_cast<int>(denm.event_type) << "\n";

                // V2X ÌÜµÏã† Í∏∞Î°ù Î∞õÏùå ‚Üí Î∏îÎ°ù ÏÉùÏÑ± ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï (atomic)
                has_v2x_data_.store(true);
            }
        );

        // Handle received CPMs - update object database
        wave_->registerCallback(WaveStack::MessageType::CPM,
            [this](const WaveStack::WaveMessage& msg) {
                if (!msg.cpm.has_value()) return;
                // Update collective perception database

                // V2X ÌÜµÏã† Í∏∞Î°ù Î∞õÏùå ‚Üí Î∏îÎ°ù ÏÉùÏÑ± ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï (atomic)
                has_v2x_data_.store(true);
            }
        );
    }

    /**
     * Update neighbor cache with ToF measurements
     */
    void updateNeighborCache() {
        // Perform ToF measurements to all neighbors
        auto tof_results = tof_->measureAllInRange(config_.wave_config.range_m);

        for (auto& [neighbor_id, candidate] : neighbor_cache_) {
            // Update with ToF measurement if available
            auto it = tof_results.find(neighbor_id);
            if (it != tof_results.end()) {
                // Store ToF transcript for later use in block creation
                // candidate.tof_transcript = it->second;
            }
        }

        // Rebuild spatial index periodically for performance (300+ vehicle scalability)
        auto now = std::chrono::steady_clock::now();
        auto rebuild_elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            now - last_spatial_rebuild_).count();

        if (rebuild_elapsed >= SPATIAL_REBUILD_INTERVAL_MS) {
            rebuildSpatialIndex();
            last_spatial_rebuild_ = now;
        }

        // Clean up stale neighbors (not seen in 5 seconds)
        cleanupStaleNeighbors();
    }

    /**
     * Try to create a block with current neighbors as witnesses
     *
     * @param all_vehicles Map of all vehicles for witness signing
     */
    void tryCreateBlock(const std::map<std::string, std::shared_ptr<IntegratedVehicle>>& all_vehicles) {
        // Prepare witness candidates from multiple sources:
        // 1. WAVE local neighbors (300m range) - using spatial index for scalability
        // 2. libp2p DHT discovered peers (global)
        std::vector<WitnessCandidate> candidates;

        // Use spatial index to get nearby neighbors efficiently (300+ vehicle scalability)
        // Limit to 50 nearest neighbors to avoid O(n¬≤) complexity in witness selection
        constexpr size_t MAX_NEARBY_NEIGHBORS = 50;
        auto nearby = getNearbyNeighbors(MAX_NEARBY_NEIGHBORS);

        std::cout << "[" << vehicle_id_ << "] Using spatial index: "
                 << nearby.size() << " nearby neighbors (out of "
                 << neighbor_cache_.size() << " total)\n";

        // Add WAVE neighbors
        for (auto& candidate : nearby) {
            auto witness_candidate = candidate;
            const std::string& neighbor_id = candidate.id;

            // CRITICAL: Bind witness's actual sign function and TLS functions
            // Find the witness vehicle and use its signer and TLS channel
            auto witness_it = all_vehicles.find(neighbor_id);
            if (witness_it != all_vehicles.end()) {
                auto witness_vehicle = witness_it->second;

                // Bind FALCON signature function
                witness_candidate.sign_function = [witness_vehicle](const std::vector<uint8_t>& data) {
                    return witness_vehicle->signAsWitness(data);
                };

                // Bind TLS 1.3 server handshake function
                witness_candidate.tls_server_handshake = [witness_vehicle](
                    const std::vector<uint8_t>& client_key_share,
                    const std::vector<uint8_t>& client_hello_data) {
                    return witness_vehicle->performTLSServerHandshake(client_key_share, client_hello_data);
                };

                // Bind TLS 1.3 application data decryption function
                witness_candidate.tls_decrypt_app_data = [witness_vehicle](
                    const std::vector<uint8_t>& encrypted_data) {
                    return witness_vehicle->decryptTLSApplicationData(encrypted_data);
                };

                candidates.push_back(witness_candidate);
            }
        }

        // Add DHT-discovered witnesses (if we have position)
        if (traci_) {
            auto my_state = traci_->getVehicleState(vehicle_id_);
            if (my_state.has_value()) {
            PositionState my_pos;
            my_pos.latitude = my_state->y;
            my_pos.longitude = my_state->x;
            my_pos.altitude_m = my_state->z;

            auto dht_witnesses = libp2p_->discoverWitnesses(my_pos, 10.0);  // 10km range

            // CRITICAL: Bind sign_function and TLS functions for DHT witnesses too
            for (auto& dht_witness : dht_witnesses) {
                auto witness_it = all_vehicles.find(dht_witness.id);
                if (witness_it != all_vehicles.end()) {
                    auto witness_vehicle = witness_it->second;

                    // Bind FALCON signature function
                    dht_witness.sign_function = [witness_vehicle](const std::vector<uint8_t>& data) {
                        return witness_vehicle->signAsWitness(data);
                    };

                    // Bind TLS 1.3 server handshake function
                    dht_witness.tls_server_handshake = [witness_vehicle](
                        const std::vector<uint8_t>& client_key_share,
                        const std::vector<uint8_t>& client_hello_data) {
                        return witness_vehicle->performTLSServerHandshake(client_key_share, client_hello_data);
                    };

                    // Bind TLS 1.3 application data decryption function
                    dht_witness.tls_decrypt_app_data = [witness_vehicle](
                        const std::vector<uint8_t>& encrypted_data) {
                        return witness_vehicle->decryptTLSApplicationData(encrypted_data);
                    };

                    candidates.push_back(dht_witness);
                }
            }

            std::cout << "[" << vehicle_id_ << "] Found " << dht_witnesses.size()
                     << " witnesses via DHT\n";
            }
        }

        // Debug: log candidate information
        std::cout << "[" << vehicle_id_ << "] tryCreateBlock: WAVE_neighbors="
                  << neighbor_cache_.size() << ", total_candidates=" << candidates.size()
                  << ", MIN_WITNESS=" << MIN_WITNESS_COUNT << "\n";

        if (candidates.size() < MIN_WITNESS_COUNT) {
            std::cout << "[" << vehicle_id_ << "] ‚ö† Insufficient witnesses (" << candidates.size()
                     << " < " << MIN_WITNESS_COUNT << "), skipping block creation\n";
            return;  // Not enough witnesses
        }

        // Get V2X communication record from WAVE stack
        V2XRecord v2x_record = wave_->getV2XRecord();

        // Add libp2p communication logs
        auto p2p_logs = libp2p_->getCommLogs();
        for (const auto& log : p2p_logs) {
            P2PCommLog comm_log;
            comm_log.timestamp = log.timestamp;
            comm_log.peer_id = log.peer.toString();
            comm_log.protocol = protocolToString(log.protocol);
            comm_log.bytes_sent = log.bytes_sent;
            comm_log.bytes_received = log.bytes_received;
            comm_log.topic = log.topic;
            if (log.block_hash.has_value()) {
                comm_log.data_hash = hashToString(*log.block_hash);
            }
            v2x_record.p2p_logs.push_back(comm_log);
        }

        // Add libp2p statistics
        size_t p2p_sent, p2p_received, p2p_bytes_tx, p2p_bytes_rx;
        libp2p_->getStatistics(p2p_sent, p2p_received, p2p_bytes_tx, p2p_bytes_rx);
        v2x_record.p2p_peers_connected = libp2p_->getConnectedPeers().size();
        v2x_record.p2p_bytes_sent = p2p_bytes_tx;
        v2x_record.p2p_bytes_received = p2p_bytes_rx;

        // Previous hash (from local chain tip)
        Hash256 prev_hash = {};
        {
            std::lock_guard<std::mutex> lock(chain_mutex_);
            if (!my_micro_chain_.empty()) {
                prev_hash = my_micro_chain_.back().block_hash;
            }
        }

        // Show WAVE range visualization
        visualizer_->showWaveRange(vehicle_id_, true);

        // Update visualization: Block creation started
        visualizer_->updateBlockStatus(vehicle_id_, SUMOVisualizer::BlockStatus::CREATING);

        // Create block with integrated ToF measurement
        auto [result, block_opt, latency_ms, failure_reason] =
            createBlockWithIntegratedToF(v2x_record, prev_hash, candidates);

        // Log result and update reputation
        std::cout << "[" << vehicle_id_ << "] Block creation: ";
        bool success = false;
        switch (result) {
            case vehicle::BlockCreator::Result::SUCCESS:
                std::cout << "SUCCESS (" << latency_ms << "ms)\n";
                success = true;
                // Update my reputation: SUCCESS
                updateMyReputation(true);
                // Update visualization: Success
                visualizer_->updateBlockStatus(vehicle_id_, SUMOVisualizer::BlockStatus::SUCCESS);
                // Store block in my micro-chain
                if (block_opt.has_value()) {
                    {
                        std::lock_guard<std::mutex> lock(chain_mutex_);
                        // Set creator_id for RSU anchoring
                        block_opt->creator_id = vehicle_id_;
                        // Compute and set block hash
                        block_opt->block_hash = block_opt->computeHash();
                        my_micro_chain_.push_back(*block_opt);
                        total_blocks_created_++;
                        // Print immediate micro-chain update
                        std::cout << "[" << vehicle_id_ << "] ‚úì Block added to micro-chain (total: "
                                  << my_micro_chain_.size() << " blocks, hash: "
                                  << hashToString(block_opt->block_hash).substr(0, 8) << "...)\n";
                    }
                    // Broadcast block via WAVE
                    broadcastBlock(*block_opt);
                }
                break;
            case vehicle::BlockCreator::Result::FALLBACK_RSU:
                std::cout << "FALLBACK_RSU: " << failure_reason << "\n";
                // Update my reputation: FAILURE (insufficient witnesses)
                updateMyReputation(false);
                visualizer_->updateBlockStatus(vehicle_id_, SUMOVisualizer::BlockStatus::FAILED);
                {
                    std::lock_guard<std::mutex> lock(chain_mutex_);
                    total_blocks_failed_++;
                }
                break;
            case vehicle::BlockCreator::Result::DIVERSITY_FAILED:
                std::cout << "DIVERSITY_FAILED: " << failure_reason << "\n";
                // Update my reputation: FAILURE (poor witness selection)
                updateMyReputation(false);
                visualizer_->updateBlockStatus(vehicle_id_, SUMOVisualizer::BlockStatus::FAILED);
                {
                    std::lock_guard<std::mutex> lock(chain_mutex_);
                    total_blocks_failed_++;
                }
                break;
            case vehicle::BlockCreator::Result::INSUFFICIENT_WITNESSES:
                std::cout << "INSUFFICIENT_WITNESSES: " << failure_reason << "\n";
                // Update my reputation: FAILURE (not enough signatures)
                updateMyReputation(false);
                visualizer_->updateBlockStatus(vehicle_id_, SUMOVisualizer::BlockStatus::FAILED);
                {
                    std::lock_guard<std::mutex> lock(chain_mutex_);
                    total_blocks_failed_++;
                }
                break;
            case vehicle::BlockCreator::Result::TIMEOUT:
                std::cout << "TIMEOUT: " << failure_reason << "\n";
                // Update my reputation: FAILURE (timeout)
                updateMyReputation(false);
                visualizer_->updateBlockStatus(vehicle_id_, SUMOVisualizer::BlockStatus::FAILED);
                {
                    std::lock_guard<std::mutex> lock(chain_mutex_);
                    total_blocks_failed_++;
                }
                break;
        }

        // Hide WAVE range after block creation
        visualizer_->showWaveRange(vehicle_id_, false);

        // Call statistics callback if registered
        if (config_.on_block_created) {
            config_.on_block_created(success, latency_ms);
        }
    }

    /**
     * Create block with integrated ToF measurement
     * (Custom implementation that uses ToFAdapter)
     */
    std::tuple<vehicle::BlockCreator::Result, std::optional<Block>, double, std::string>
    createBlockWithIntegratedToF(
            const V2XRecord& v2x_record,
            const Hash256& prev_hash,
            const std::vector<WitnessCandidate>& candidates) {

        auto start_time = std::chrono::high_resolution_clock::now();

        // Filter eligible candidates (reputation + blacklist check)
        std::vector<WitnessCandidate> eligible;
        for (const auto& c : candidates) {
            // Check if blacklisted
            if (isBlacklisted(c.id)) {
                std::cout << "  [buildWitnessCandidateList] Filtered out blacklisted vehicle: "
                          << c.id << "\n";
                continue;
            }

            // Check if eligible (reputation, etc.)
            if (c.isEligible()) {
                eligible.push_back(c);
            }
        }

        // Cleanup expired blacklist entries periodically
        cleanupBlacklist();

        if (eligible.size() < MIN_WITNESS_COUNT) {
            std::string reason = "Insufficient eligible witnesses: " +
                std::to_string(eligible.size()) + " < " + std::to_string(MIN_WITNESS_COUNT);
            auto latency = std::chrono::duration<double, std::milli>(
                std::chrono::high_resolution_clock::now() - start_time).count();
            return {vehicle::BlockCreator::Result::FALLBACK_RSU, std::nullopt, latency, reason};
        }

        // CRITICAL: Use actual BlockCreator instead of mock!
        // BlockCreator handles:
        // - ToF verification (Phase C)
        // - Diversity selection (Phase D)
        // - Witness signature collection (Phase E)
        // - Real FALCON-512 signatures from each witness

        return block_creator_->createBlock(v2x_record, prev_hash, eligible, false);
    }

    /**
     * Broadcast block via WAVE and libp2p
     * Enhanced with TEE commit validation logging
     */
    void broadcastBlock(const Block& block) {
        // Serialize block
        std::vector<uint8_t> block_data;  // Would serialize block here

        std::cout << "[" << vehicle_id_ << "] Broadcasting block...\n";

        // Log TEE commit information
        if (block.header.has_tee_commit) {
            std::cout << "[" << vehicle_id_ << "]   TEE commit: "
                      << hashToString(block.header.tee_aggregate_hash).substr(0, 16) << "...\n";
            std::cout << "[" << vehicle_id_ << "]   Witnesses: "
                      << block.header.witness_sigs.size() << " signatures\n";
        } else {
            std::cout << "[" << vehicle_id_ << "]   No TEE commit (fallback mode)\n";
        }

        // Broadcast via WAVE (local, 300m)
        // wave_->sendCustomMessage(block_data);

        // Broadcast via libp2p GossipSub (global)
        libp2p_->publish("meshchain/blocks", block_data);

        // Provide block via Bitswap
        libp2p_->provideBlock(block);

        std::cout << "[" << vehicle_id_ << "] ‚úì Block broadcasted via WAVE + libp2p\n";

        // NOTE: RSUÏóê Ï†ÑÏÜ°ÌïòÏßÄ ÏïäÏùå!
        // RSUÎäî L1 ÏïµÏª§ÎßÅ ÏãúÏ†ê(60Ï¥àÎßàÎã§)Ïóê onAnchorRequest()Î•º ÌÜµÌï¥
        // pull Î∞©ÏãùÏúºÎ°ú Ïù¥ Ï∞®ÎüâÏùò micro-chainÏóêÏÑú Î∏îÎ°ùÏùÑ Í∞ÄÏ†∏Í∞ëÎãàÎã§.
    }

    /**
     * Verify received block with TEE commit validation
     *
     * This method is called when a block is received from another vehicle
     * Validates:
     * 1. Block structure integrity
     * 2. Creator signature
     * 3. TEE commit (if present)
     * 4. Individual witness signatures (fallback)
     *
     * @param block Block to verify
     * @return True if block is valid
     */
    bool verifyReceivedBlock(const Block& block) {
        std::cout << "[" << vehicle_id_ << "] Verifying received block from "
                  << block.creator_id << "\n";

        // Step 1: Basic structure validation
        if (!block.header.validateStructure()) {
            std::cout << "[" << vehicle_id_ << "] ‚úó Block structure invalid\n";
            return false;
        }

        // Step 2: Verify creator signature
        std::vector<uint8_t> header_bytes;  // Would serialize header
        if (block.header.creator_sig.empty()) {
            std::cout << "[" << vehicle_id_ << "] ‚úó Missing creator signature\n";
            return false;
        }

        // Step 3: TEE commit verification (if present)
        if (block.header.has_tee_commit) {
            std::cout << "[" << vehicle_id_ << "]   Verifying TEE commit...\n";

            // Verify TEE commit against witness signatures
            bool tee_valid = tee_aggregator_->verifyTEECommit(
                getTEECommitFromBlock(block),
                block.header,
                block.header.witness_sigs
            );

            if (!tee_valid) {
                std::cout << "[" << vehicle_id_ << "] ‚úó TEE commit verification failed\n";
                // Fallback to individual signature verification
                std::cout << "[" << vehicle_id_ << "]   Falling back to individual signature verification\n";
                return verifyIndividualSignatures(block);
            }

            std::cout << "[" << vehicle_id_ << "] ‚úì TEE commit verified successfully\n";
            return true;
        }

        // Step 4: Fallback - verify individual signatures
        std::cout << "[" << vehicle_id_ << "]   No TEE commit, verifying individual signatures\n";
        return verifyIndividualSignatures(block);
    }

private:
    /**
     * Extract TEE commit from block header
     */
    crypto::TEECommit getTEECommitFromBlock(const Block& block) const {
        crypto::TEECommit commit;
        commit.aggregate_hash = block.header.tee_aggregate_hash;
        commit.signature_hashes = block.header.tee_signature_hashes;
        commit.witness_count = block.header.witness_sigs.size();
        commit.block_header_hash = block.header.computeHeaderHash();
        commit.witness_bitmap = block.header.witness_bitmap;
        return commit;
    }

    /**
     * Verify individual witness signatures (fallback)
     */
    bool verifyIndividualSignatures(const Block& block) {
        if (block.header.witness_sigs.empty()) {
            std::cout << "[" << vehicle_id_ << "] ‚úó No witness signatures\n";
            return false;
        }

        size_t verified_count = 0;
        Hash256 header_hash = block.header.computeHeaderHash();
        std::vector<uint8_t> hash_vec(header_hash.begin(), header_hash.end());

        for (size_t i = 0; i < block.header.witness_sigs.size(); ++i) {
            const auto& signature = block.header.witness_sigs[i];

            // Get witness public key from cache
            // In production, extract from block or look up from certificate
            // For now, skip individual verification in simulation

            verified_count++;
        }

        std::cout << "[" << vehicle_id_ << "]   Verified " << verified_count
                  << " / " << block.header.witness_sigs.size()
                  << " witness signatures\n";

        // Consider block valid if majority of signatures verified
        bool valid = (verified_count >= block.header.witness_sigs.size() / 2);

        if (valid) {
            std::cout << "[" << vehicle_id_ << "] ‚úì Block verified via individual signatures\n";
        } else {
            std::cout << "[" << vehicle_id_ << "] ‚úó Insufficient valid signatures\n";
        }

        return valid;
    }

    /**
     * Helper: Convert protocol enum to string
     */
    std::string protocolToString(LibP2PNode::Protocol protocol) const {
        switch (protocol) {
            case LibP2PNode::Protocol::GOSSIPSUB: return "GOSSIPSUB";
            case LibP2PNode::Protocol::BITSWAP: return "BITSWAP";
            case LibP2PNode::Protocol::DHT: return "DHT";
            case LibP2PNode::Protocol::PING: return "PING";
            case LibP2PNode::Protocol::IDENTIFY: return "IDENTIFY";
            case LibP2PNode::Protocol::CUSTOM: return "CUSTOM";
            default: return "UNKNOWN";
        }
    }

    /**
     * Helper: Convert hash to string
     */
    std::string hashToString(const Hash256& hash) const {
        std::string result;
        for (uint8_t byte : hash) {
            char hex[3];
            snprintf(hex, sizeof(hex), "%02x", byte);
            result += hex;
        }
        return result;
    }
};

} // namespace integration
} // namespace meshchain

#endif // MESHCHAIN_INTEGRATED_VEHICLE_H
