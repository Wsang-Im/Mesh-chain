#ifndef MESHCHAIN_TEE_AGGREGATOR_H
#define MESHCHAIN_TEE_AGGREGATOR_H

/**
 * TEE (Trusted Execution Environment) Signature Aggregator
 *
 * Supports two protocols:
 *
 * 1. LEGACY: Signature aggregation (deprecated)
 *    - Collects individual FALCON-512 signatures from witnesses
 *    - Generates aggregated commit (SHA3-256 hash of all signatures)
 *
 * 2. NEW: Attestquorum protocol (Paper Section 3.2)
 *    - Witnesses vote via MAC over secure ML-KEM-768 TLS 1.3 channels
 *    - TEE aggregates MACs and produces attestquorum signature (~128 bytes)
 *    - Reduces block size from ~4.2KB to ~1.4KB (w=3 witnesses)
 *    - Eliminates packet fragmentation in WAVE networks
 *
 * Key features:
 * - Backward compatible with existing block structure
 * - Compatible with OMNet++ integration
 * - Verifiable proof of witness set participation
 */

#include "../common/types.h"
#include "../common/block.h"
#include "sha3_wrapper.h"
#include "pqc_signatures.h"
#include <vector>
#include <string>
#include <memory>
#include <chrono>
#include <iostream>

namespace meshchain {
namespace crypto {

/**
 * TEE Aggregated Commit Structure
 *
 * Represents the aggregated commitment from all witness signatures
 */
struct TEECommit {
    Hash256 aggregate_hash;              // SHA3-256(all witness signatures)
    std::vector<Hash256> signature_hashes;  // Individual signature hashes for verification
    size_t witness_count;                // Number of witnesses
    Timestamp created_at;                // When commit was created

    // Metadata for verification
    Hash256 block_header_hash;           // Hash of the block header being signed
    std::bitset<MAX_WITNESS_COUNT> witness_bitmap;  // Which witnesses signed

    TEECommit() : witness_count(0) {
        aggregate_hash.fill(0);
        block_header_hash.fill(0);
        created_at = std::chrono::system_clock::now();
    }

    /**
     * Serialize TEE commit for storage/transmission
     */
    std::vector<uint8_t> serialize() const {
        std::vector<uint8_t> data;
        data.reserve(1024);

        // Serialize aggregate hash
        data.insert(data.end(), aggregate_hash.begin(), aggregate_hash.end());

        // Serialize witness count
        uint64_t count = witness_count;
        for (size_t i = 0; i < 8; ++i) {
            data.push_back(static_cast<uint8_t>((count >> (i * 8)) & 0xFF));
        }

        // Serialize block header hash
        data.insert(data.end(), block_header_hash.begin(), block_header_hash.end());

        // Serialize individual signature hashes
        for (const auto& sig_hash : signature_hashes) {
            data.insert(data.end(), sig_hash.begin(), sig_hash.end());
        }

        return data;
    }
};

/**
 * TEE Signature Aggregator
 *
 * Simulates TEE-based secure aggregation of witness signatures
 * In production, this would run inside SGX/TrustZone enclave
 */
class TEEAggregator {
public:
    struct Config {
        bool enable_individual_verification;  // Verify each signature before aggregation
        double max_aggregation_time_ms;       // Maximum time for aggregation (default: 10ms)

        Config()
            : enable_individual_verification(true)
            , max_aggregation_time_ms(10.0) {}
    };

    struct AggregationResult {
        bool success;
        TEECommit commit;
        size_t verified_count;
        size_t failed_count;
        double aggregation_time_ms;
        std::string failure_reason;
    };

    // NEW: Attestdiv result structure (Paper Section 3.2 - Phase 2)
    // Phase 2: Witness Selection and Diversity Attestation
    // attestdiv ← SignTEE(Hash(W)||metrics) where W is selected witness set
    struct AttestdivResult {
        bool success;
        std::vector<uint8_t> attestdiv;  // TEE signature over diversity metrics (~658 bytes FALCON-512)
        size_t witness_count;            // Number of witnesses in the selected set
        double generation_time_ms;       // Time to generate attestdiv
        std::string failure_reason;      // Error message if failed

        // Diversity metrics (for debugging/logging)
        size_t oem_diversity_count;      // Number of unique OEMs
        double geographical_spread;      // Geographical diversity metric
        double avg_reputation;           // Average reputation of witnesses

        AttestdivResult() : success(false), witness_count(0), generation_time_ms(0.0),
                           oem_diversity_count(0), geographical_spread(0.0), avg_reputation(0.0) {}
    };

    // NEW: Attestquorum result structure (Paper Section 3.2)
    struct AttestquorumResult {
        bool success;
        std::vector<uint8_t> attestquorum;  // TEE signature over aggregated votes (~128 bytes)
        Hash256 witness_merkle_root;        // Merkle root of witness identities
        size_t witness_count;               // Number of witnesses who voted
        double generation_time_ms;          // Time to generate attestquorum
        std::string failure_reason;         // Error message if failed

        AttestquorumResult() : success(false), witness_count(0), generation_time_ms(0.0) {
            witness_merkle_root.fill(0);
        }
    };

private:
    Config config_;

public:
    explicit TEEAggregator(const Config& config = Config())
        : config_(config) {}

    /**
     * Aggregate witness signatures into TEE commit
     *
     * @param block_header Header of the block being signed
     * @param witness_signatures List of witness signatures
     * @param witness_public_keys List of witness public keys (for verification)
     * @return Aggregation result with TEE commit
     */
    AggregationResult aggregateSignatures(
            const BlockHeader& block_header,
            const std::vector<std::vector<uint8_t>>& witness_signatures,
            const std::vector<std::vector<uint8_t>>& witness_public_keys) {

        auto start_time = std::chrono::high_resolution_clock::now();

        AggregationResult result;
        result.success = false;
        result.verified_count = 0;
        result.failed_count = 0;

        std::cout << "[TEE Aggregator] Starting aggregation of "
                  << witness_signatures.size() << " witness signatures\n";

        // Validate input
        if (witness_signatures.empty()) {
            result.failure_reason = "No witness signatures provided";
            result.aggregation_time_ms = getElapsedMs(start_time);
            return result;
        }

        if (config_.enable_individual_verification &&
            witness_signatures.size() != witness_public_keys.size()) {
            result.failure_reason = "Signature and public key count mismatch";
            result.aggregation_time_ms = getElapsedMs(start_time);
            return result;
        }

        // Compute block header hash (what witnesses signed)
        Hash256 header_hash = block_header.computeHeaderHash();
        result.commit.block_header_hash = header_hash;

        // Step 1: Verify individual signatures (if enabled)
        std::vector<Hash256> verified_sig_hashes;
        std::bitset<MAX_WITNESS_COUNT> verified_bitmap;

        for (size_t i = 0; i < witness_signatures.size(); ++i) {
            const auto& signature = witness_signatures[i];

            if (config_.enable_individual_verification && i < witness_public_keys.size()) {
                const auto& pubkey = witness_public_keys[i];

                // Verify FALCON-512 signature
                bool valid = verifyFalconSignature(header_hash, signature, pubkey);

                if (!valid) {
                    std::cout << "[TEE Aggregator] ⚠ Signature #" << i
                              << " verification failed\n";
                    result.failed_count++;
                    continue;
                }
            }

            // Hash individual signature for commit
            Hash256 sig_hash = SHA3::hash(signature);
            verified_sig_hashes.push_back(sig_hash);
            verified_bitmap.set(i);
            result.verified_count++;
        }

        std::cout << "[TEE Aggregator] Verified " << result.verified_count
                  << " / " << witness_signatures.size() << " signatures\n";

        // Check if we have enough verified signatures
        if (verified_sig_hashes.empty()) {
            result.failure_reason = "No signatures passed verification";
            result.aggregation_time_ms = getElapsedMs(start_time);
            return result;
        }

        // Step 2: Create aggregated commit
        // Concatenate all verified signature hashes in deterministic order
        std::vector<uint8_t> aggregate_input;
        aggregate_input.reserve(verified_sig_hashes.size() * 32);

        for (const auto& sig_hash : verified_sig_hashes) {
            aggregate_input.insert(aggregate_input.end(),
                                  sig_hash.begin(), sig_hash.end());
        }

        // Compute aggregate hash (TEE commit)
        Hash256 aggregate_hash = SHA3::hash(aggregate_input);

        // Step 3: Build TEE commit structure
        result.commit.aggregate_hash = aggregate_hash;
        result.commit.signature_hashes = verified_sig_hashes;
        result.commit.witness_count = result.verified_count;
        result.commit.witness_bitmap = verified_bitmap;
        result.commit.created_at = std::chrono::system_clock::now();

        result.success = true;
        result.aggregation_time_ms = getElapsedMs(start_time);

        std::cout << "[TEE Aggregator] ✓ Aggregation complete in "
                  << result.aggregation_time_ms << "ms\n";
        std::cout << "[TEE Aggregator]   Aggregate hash: "
                  << hashToHexString(aggregate_hash).substr(0, 16) << "...\n";

        return result;
    }

    /**
     * Verify TEE commit against block and signatures
     *
     * This verifies that the TEE commit matches the provided signatures
     * Used by validators to check block integrity
     *
     * @param commit TEE commit to verify
     * @param block_header Block header that was signed
     * @param witness_signatures Original witness signatures
     * @return True if commit is valid
     */
    bool verifyTEECommit(
            const TEECommit& commit,
            const BlockHeader& block_header,
            const std::vector<std::vector<uint8_t>>& witness_signatures) {

        std::cout << "[TEE Aggregator] Verifying TEE commit...\n";

        // Check witness count matches
        if (commit.witness_count != witness_signatures.size()) {
            std::cout << "[TEE Aggregator] ✗ Witness count mismatch: commit="
                      << commit.witness_count << ", actual="
                      << witness_signatures.size() << "\n";
            return false;
        }

        // Verify block header hash
        Hash256 header_hash = block_header.computeHeaderHash();
        if (commit.block_header_hash != header_hash) {
            std::cout << "[TEE Aggregator] ✗ Block header hash mismatch\n";
            return false;
        }

        // Recompute signature hashes
        std::vector<Hash256> recomputed_hashes;
        for (const auto& signature : witness_signatures) {
            Hash256 sig_hash = SHA3::hash(signature);
            recomputed_hashes.push_back(sig_hash);
        }

        // Verify signature hashes match commit
        if (recomputed_hashes.size() != commit.signature_hashes.size()) {
            std::cout << "[TEE Aggregator] ✗ Signature hash count mismatch\n";
            return false;
        }

        for (size_t i = 0; i < recomputed_hashes.size(); ++i) {
            if (recomputed_hashes[i] != commit.signature_hashes[i]) {
                std::cout << "[TEE Aggregator] ✗ Signature hash #" << i
                          << " mismatch\n";
                return false;
            }
        }

        // Recompute aggregate hash
        std::vector<uint8_t> aggregate_input;
        aggregate_input.reserve(commit.signature_hashes.size() * 32);

        for (const auto& sig_hash : commit.signature_hashes) {
            aggregate_input.insert(aggregate_input.end(),
                                  sig_hash.begin(), sig_hash.end());
        }

        Hash256 recomputed_aggregate = SHA3::hash(aggregate_input);

        if (recomputed_aggregate != commit.aggregate_hash) {
            std::cout << "[TEE Aggregator] ✗ Aggregate hash mismatch\n";
            return false;
        }

        std::cout << "[TEE Aggregator] ✓ TEE commit verified successfully\n";
        return true;
    }

    /**
     * Generate attestdiv for witness selection (Phase 2 - Paper Section 3.2)
     *
     * This implements TEE-based diversity attestation that proves the selected
     * witness set satisfies diversity requirements (OEM diversity, geographical
     * spread, reputation thresholds, etc.)
     *
     * Protocol flow:
     * 1. Creator selects witness set W based on diversity criteria
     * 2. Creator computes diversity metrics (OEM count, geo spread, etc.)
     * 3. TEE generates attestdiv ← SignTEE(Hash(W)||metrics)
     * 4. Block includes attestdiv to prove witness diversity
     *
     * Fallback mechanism:
     * - If insufficient diverse witnesses, may use RSU super-witnessing
     *
     * @param witness_ids Vector of selected witness identities
     * @param oem_diversity_count Number of unique OEMs in witness set
     * @param geographical_spread Geographical diversity metric
     * @param avg_reputation Average reputation of selected witnesses
     * @param creator_signer Creator's FALCON signer (TEE uses it to sign attestdiv)
     * @return Attestdiv result with TEE signature
     */
    AttestdivResult generateAttestdiv(
            const std::vector<VehicleID>& witness_ids,
            size_t oem_diversity_count,
            double geographical_spread,
            double avg_reputation,
            const std::shared_ptr<FalconSigner>& creator_signer) {

        auto start_time = std::chrono::high_resolution_clock::now();

        AttestdivResult result;
        result.success = false;

        std::cout << "[TEE Attestdiv] Generating diversity attestation for "
                  << witness_ids.size() << " witnesses\n";

        // Validate input
        if (witness_ids.empty()) {
            result.failure_reason = "No witnesses provided";
            result.generation_time_ms = getElapsedMs(start_time);
            return result;
        }

        // Step 1: Compute Hash(W) - hash of witness identities (sorted for determinism)
        std::vector<std::string> sorted_witness_ids = witness_ids;
        std::sort(sorted_witness_ids.begin(), sorted_witness_ids.end());

        std::vector<uint8_t> witness_set_data;
        for (const auto& witness_id : sorted_witness_ids) {
            witness_set_data.insert(witness_set_data.end(),
                                   witness_id.begin(), witness_id.end());
        }
        Hash256 witness_set_hash = SHA3::hash(witness_set_data);

        // Step 2: Encode diversity metrics
        // Format: [oem_count(8B)] [geo_spread(8B)] [avg_rep(8B)]
        std::vector<uint8_t> metrics_data;
        metrics_data.reserve(24);

        // Encode OEM diversity count (8 bytes, little-endian)
        uint64_t oem_count = static_cast<uint64_t>(oem_diversity_count);
        for (size_t i = 0; i < 8; ++i) {
            metrics_data.push_back(static_cast<uint8_t>((oem_count >> (i * 8)) & 0xFF));
        }

        // Encode geographical spread (8 bytes, as uint64_t scaled by 1e6)
        uint64_t geo_scaled = static_cast<uint64_t>(geographical_spread * 1000000.0);
        for (size_t i = 0; i < 8; ++i) {
            metrics_data.push_back(static_cast<uint8_t>((geo_scaled >> (i * 8)) & 0xFF));
        }

        // Encode average reputation (8 bytes, as uint64_t scaled by 1e6)
        uint64_t rep_scaled = static_cast<uint64_t>(avg_reputation * 1000000.0);
        for (size_t i = 0; i < 8; ++i) {
            metrics_data.push_back(static_cast<uint8_t>((rep_scaled >> (i * 8)) & 0xFF));
        }

        // Step 3: Compute Hash(W)||metrics
        std::vector<uint8_t> attestdiv_input;
        attestdiv_input.reserve(32 + 24);
        attestdiv_input.insert(attestdiv_input.end(),
                              witness_set_hash.begin(), witness_set_hash.end());
        attestdiv_input.insert(attestdiv_input.end(),
                              metrics_data.begin(), metrics_data.end());

        Hash256 attestdiv_hash = SHA3::hash(attestdiv_input);

        // Step 4: TEE signs the diversity attestation
        // In production: Use hardware TEE signature (e.g., Intel SGX ECDSA ~128 bytes)
        // In simulation: Use simplified 128-byte signature for performance
        std::vector<uint8_t> attestdiv_sig(128);  // TEE signature target: 128 bytes

        // Simulate TEE signature: SHA3-256 repeated to fill 128 bytes
        Hash256 sig_base = SHA3::hash(std::vector<uint8_t>(attestdiv_hash.begin(), attestdiv_hash.end()));
        for (size_t i = 0; i < 128; i += 32) {
            size_t copy_len = std::min(size_t(32), 128 - i);
            std::memcpy(&attestdiv_sig[i], sig_base.data(), copy_len);
            // Mix in iteration number for uniqueness
            attestdiv_sig[i] ^= static_cast<uint8_t>(i);
        }

        // Store results
        result.attestdiv = attestdiv_sig;
        result.witness_count = witness_ids.size();
        result.oem_diversity_count = oem_diversity_count;
        result.geographical_spread = geographical_spread;
        result.avg_reputation = avg_reputation;
        result.success = true;
        result.generation_time_ms = getElapsedMs(start_time);

        std::cout << "[TEE Attestdiv] ✓ Diversity attestation generated in "
                  << result.generation_time_ms << "ms\n";
        std::cout << "[TEE Attestdiv]   Attestdiv size: "
                  << attestdiv_sig.size() << " bytes\n";
        std::cout << "[TEE Attestdiv]   Witness count: " << witness_ids.size() << "\n";
        std::cout << "[TEE Attestdiv]   OEM diversity: " << oem_diversity_count << "\n";
        std::cout << "[TEE Attestdiv]   Geo spread: " << geographical_spread << "\n";
        std::cout << "[TEE Attestdiv]   Avg reputation: " << avg_reputation << "\n";

        return result;
    }

    /**
     * Generate attestquorum from witness vote MACs (NEW PROTOCOL - Paper Section 3.2)
     *
     * This implements the TEE-based attestquorum protocol that replaces individual
     * FALCON-512 signatures with MACs, dramatically reducing block size.
     *
     * Protocol flow:
     * 1. Witnesses vote via MAC over secure ML-KEM-768 TLS 1.3 channels
     * 2. Creator collects all witness vote MACs
     * 3. TEE aggregates MACs and generates attestquorum (~128 bytes)
     * 4. Block includes: creator_sig + attestquorum (not individual witness_sigs)
     *
     * Block size reduction (w=3 witnesses):
     * - Old: creator_sig (690B) + 3×witness_sigs (3×690B = 2070B) = 2760B
     * - New: creator_sig (690B) + 3×MACs (3×32B = 96B) + attestquorum (128B) = 914B
     * - Savings: 1846B (67% reduction)
     *
     * @param block_header Header of the block being voted on
     * @param witness_vote_macs Vector of witness vote MACs (HMAC-SHA256, 32 bytes each)
     * @param witness_ids Vector of witness identities (for Merkle root)
     * @param creator_signer Creator's FALCON signer (TEE uses it to sign attestquorum)
     * @return Attestquorum result with TEE signature
     */
    AttestquorumResult generateAttestquorum(
            const BlockHeader& block_header,
            const std::vector<std::vector<uint8_t>>& witness_vote_macs,
            const std::vector<VehicleID>& witness_ids,
            const std::shared_ptr<FalconSigner>& creator_signer) {

        auto start_time = std::chrono::high_resolution_clock::now();

        AttestquorumResult result;
        result.success = false;

        std::cout << "[TEE Attestquorum] Generating attestquorum for "
                  << witness_vote_macs.size() << " witness votes\n";

        // Validate input
        if (witness_vote_macs.empty()) {
            result.failure_reason = "No witness vote MACs provided";
            result.generation_time_ms = getElapsedMs(start_time);
            return result;
        }

        if (witness_vote_macs.size() != witness_ids.size()) {
            result.failure_reason = "MAC and witness ID count mismatch";
            result.generation_time_ms = getElapsedMs(start_time);
            return result;
        }

        // Validate MAC sizes (HMAC-SHA256 = 32 bytes)
        for (size_t i = 0; i < witness_vote_macs.size(); ++i) {
            if (witness_vote_macs[i].size() != 32) {
                result.failure_reason = "Invalid MAC size at index " + std::to_string(i);
                result.generation_time_ms = getElapsedMs(start_time);
                return result;
            }
        }

        // Step 1: Compute Merkle root of witness identities (deterministic ordering)
        std::vector<std::string> sorted_witness_ids = witness_ids;
        std::sort(sorted_witness_ids.begin(), sorted_witness_ids.end());

        std::vector<std::vector<uint8_t>> witness_id_hashes;
        for (const auto& witness_id : sorted_witness_ids) {
            std::vector<uint8_t> id_bytes(witness_id.begin(), witness_id.end());
            Hash256 id_hash = SHA3::hash(id_bytes);
            witness_id_hashes.push_back(std::vector<uint8_t>(id_hash.begin(), id_hash.end()));
        }

        // Compute Merkle root (simple hash of concatenated hashes for now)
        std::vector<uint8_t> merkle_input;
        for (const auto& id_hash : witness_id_hashes) {
            merkle_input.insert(merkle_input.end(), id_hash.begin(), id_hash.end());
        }
        Hash256 witness_merkle_root = SHA3::hash(merkle_input);
        result.witness_merkle_root = witness_merkle_root;

        std::cout << "[TEE Attestquorum] Witness Merkle root: "
                  << hashToHexString(witness_merkle_root).substr(0, 16) << "...\n";

        // Step 2: Aggregate witness vote MACs
        // Concatenate all MACs in deterministic order (sorted by witness ID)
        std::vector<std::pair<std::string, std::vector<uint8_t>>> mac_pairs;
        for (size_t i = 0; i < witness_ids.size(); ++i) {
            mac_pairs.push_back({witness_ids[i], witness_vote_macs[i]});
        }
        std::sort(mac_pairs.begin(), mac_pairs.end(),
                  [](const auto& a, const auto& b) { return a.first < b.first; });

        std::vector<uint8_t> aggregated_macs;
        aggregated_macs.reserve(mac_pairs.size() * 32);
        for (const auto& pair : mac_pairs) {
            aggregated_macs.insert(aggregated_macs.end(),
                                  pair.second.begin(), pair.second.end());
        }

        std::cout << "[TEE Attestquorum] Aggregated " << mac_pairs.size()
                  << " MACs (" << aggregated_macs.size() << " bytes)\n";

        // Step 3: Generate attestquorum signature
        // TEE signs: H(block_header || witness_merkle_root || aggregated_macs)
        Hash256 header_hash = block_header.computeHeaderHash();

        std::vector<uint8_t> attestquorum_input;
        attestquorum_input.reserve(32 + 32 + aggregated_macs.size());
        attestquorum_input.insert(attestquorum_input.end(),
                                 header_hash.begin(), header_hash.end());
        attestquorum_input.insert(attestquorum_input.end(),
                                 witness_merkle_root.begin(), witness_merkle_root.end());
        attestquorum_input.insert(attestquorum_input.end(),
                                 aggregated_macs.begin(), aggregated_macs.end());

        Hash256 attestquorum_hash = SHA3::hash(attestquorum_input);

        // TEE signs the attestquorum hash
        // In production: Use hardware TEE signature (e.g., Intel SGX ECDSA ~128 bytes)
        // In simulation: Use simplified 128-byte signature for performance and size
        std::vector<uint8_t> attestquorum_sig(128);  // TEE signature target: 128 bytes

        // Simulate TEE signature: SHA3-256 repeated to fill 128 bytes
        Hash256 sig_base = SHA3::hash(std::vector<uint8_t>(attestquorum_hash.begin(), attestquorum_hash.end()));
        for (size_t i = 0; i < 128; i += 32) {
            size_t copy_len = std::min(size_t(32), 128 - i);
            std::memcpy(&attestquorum_sig[i], sig_base.data(), copy_len);
            // Mix in iteration number for uniqueness
            attestquorum_sig[i] ^= static_cast<uint8_t>(i);
        }

        result.attestquorum = attestquorum_sig;
        result.witness_count = witness_vote_macs.size();
        result.success = true;
        result.generation_time_ms = getElapsedMs(start_time);

        std::cout << "[TEE Attestquorum] ✓ Attestquorum generated in "
                  << result.generation_time_ms << "ms\n";
        std::cout << "[TEE Attestquorum]   Signature size: "
                  << attestquorum_sig.size() << " bytes\n";
        std::cout << "[TEE Attestquorum]   Block size reduction: "
                  << "~" << (witness_vote_macs.size() * 690 - attestquorum_sig.size())
                  << " bytes saved\n";

        return result;
    }

private:
    /**
     * Verify FALCON-512 signature
     * Wrapper for signature verification
     */
    bool verifyFalconSignature(
            const Hash256& header_hash,
            const std::vector<uint8_t>& signature,
            const std::vector<uint8_t>& public_key) {

        // Convert hash to vector for verification
        std::vector<uint8_t> hash_vec(header_hash.begin(), header_hash.end());

        // Create temporary signer for verification
        FalconSigner verifier;

        // Verify signature
        return verifier.verify(hash_vec, signature, public_key);
    }

    /**
     * Convert hash to hex string for logging
     */
    std::string hashToHexString(const Hash256& hash) const {
        std::string result;
        result.reserve(64);
        for (uint8_t byte : hash) {
            char hex[3];
            snprintf(hex, sizeof(hex), "%02x", byte);
            result += hex;
        }
        return result;
    }

    /**
     * Get elapsed time in milliseconds
     */
    double getElapsedMs(
            const std::chrono::high_resolution_clock::time_point& start) const {
        auto now = std::chrono::high_resolution_clock::now();
        return std::chrono::duration<double, std::milli>(now - start).count();
    }
};

} // namespace crypto
} // namespace meshchain

#endif // MESHCHAIN_TEE_AGGREGATOR_H
