#ifndef MESHCHAIN_TEE_AGGREGATOR_H
#define MESHCHAIN_TEE_AGGREGATOR_H

/**
 * TEE (Trusted Execution Environment) Signature Aggregator
 *
 * Aggregates witness signatures into a single cryptographic commit
 * using TEE-based secure computation.
 *
 * Key features:
 * - Collects individual FALCON-512 signatures from witnesses
 * - Verifies each signature against block header
 * - Generates aggregated commit (SHA3-256 hash of all signatures)
 * - Provides verifiable proof of witness set participation
 * - Compatible with existing block structure and OMNet++ integration
 */

#include "../common/types.h"
#include "../common/block.h"
#include "sha3_wrapper.h"
#include "pqc_signatures.h"
#include <vector>
#include <string>
#include <memory>
#include <chrono>
#include <iostream>

namespace meshchain {
namespace crypto {

/**
 * TEE Aggregated Commit Structure
 *
 * Represents the aggregated commitment from all witness signatures
 */
struct TEECommit {
    Hash256 aggregate_hash;              // SHA3-256(all witness signatures)
    std::vector<Hash256> signature_hashes;  // Individual signature hashes for verification
    size_t witness_count;                // Number of witnesses
    Timestamp created_at;                // When commit was created

    // Metadata for verification
    Hash256 block_header_hash;           // Hash of the block header being signed
    std::bitset<MAX_WITNESS_COUNT> witness_bitmap;  // Which witnesses signed

    TEECommit() : witness_count(0) {
        aggregate_hash.fill(0);
        block_header_hash.fill(0);
        created_at = std::chrono::system_clock::now();
    }

    /**
     * Serialize TEE commit for storage/transmission
     */
    std::vector<uint8_t> serialize() const {
        std::vector<uint8_t> data;
        data.reserve(1024);

        // Serialize aggregate hash
        data.insert(data.end(), aggregate_hash.begin(), aggregate_hash.end());

        // Serialize witness count
        uint64_t count = witness_count;
        for (size_t i = 0; i < 8; ++i) {
            data.push_back(static_cast<uint8_t>((count >> (i * 8)) & 0xFF));
        }

        // Serialize block header hash
        data.insert(data.end(), block_header_hash.begin(), block_header_hash.end());

        // Serialize individual signature hashes
        for (const auto& sig_hash : signature_hashes) {
            data.insert(data.end(), sig_hash.begin(), sig_hash.end());
        }

        return data;
    }
};

/**
 * TEE Signature Aggregator
 *
 * Simulates TEE-based secure aggregation of witness signatures
 * In production, this would run inside SGX/TrustZone enclave
 */
class TEEAggregator {
public:
    struct Config {
        bool enable_individual_verification;  // Verify each signature before aggregation
        double max_aggregation_time_ms;       // Maximum time for aggregation (default: 10ms)

        Config()
            : enable_individual_verification(true)
            , max_aggregation_time_ms(10.0) {}
    };

    struct AggregationResult {
        bool success;
        TEECommit commit;
        size_t verified_count;
        size_t failed_count;
        double aggregation_time_ms;
        std::string failure_reason;
    };

private:
    Config config_;

public:
    explicit TEEAggregator(const Config& config = Config())
        : config_(config) {}

    /**
     * Aggregate witness signatures into TEE commit
     *
     * @param block_header Header of the block being signed
     * @param witness_signatures List of witness signatures
     * @param witness_public_keys List of witness public keys (for verification)
     * @return Aggregation result with TEE commit
     */
    AggregationResult aggregateSignatures(
            const BlockHeader& block_header,
            const std::vector<std::vector<uint8_t>>& witness_signatures,
            const std::vector<std::vector<uint8_t>>& witness_public_keys) {

        auto start_time = std::chrono::high_resolution_clock::now();

        AggregationResult result;
        result.success = false;
        result.verified_count = 0;
        result.failed_count = 0;

        std::cout << "[TEE Aggregator] Starting aggregation of "
                  << witness_signatures.size() << " witness signatures\n";

        // Validate input
        if (witness_signatures.empty()) {
            result.failure_reason = "No witness signatures provided";
            result.aggregation_time_ms = getElapsedMs(start_time);
            return result;
        }

        if (config_.enable_individual_verification &&
            witness_signatures.size() != witness_public_keys.size()) {
            result.failure_reason = "Signature and public key count mismatch";
            result.aggregation_time_ms = getElapsedMs(start_time);
            return result;
        }

        // Compute block header hash (what witnesses signed)
        Hash256 header_hash = block_header.computeHeaderHash();
        result.commit.block_header_hash = header_hash;

        // Step 1: Verify individual signatures (if enabled)
        std::vector<Hash256> verified_sig_hashes;
        std::bitset<MAX_WITNESS_COUNT> verified_bitmap;

        for (size_t i = 0; i < witness_signatures.size(); ++i) {
            const auto& signature = witness_signatures[i];

            if (config_.enable_individual_verification && i < witness_public_keys.size()) {
                const auto& pubkey = witness_public_keys[i];

                // Verify FALCON-512 signature
                bool valid = verifyFalconSignature(header_hash, signature, pubkey);

                if (!valid) {
                    std::cout << "[TEE Aggregator] ⚠ Signature #" << i
                              << " verification failed\n";
                    result.failed_count++;
                    continue;
                }
            }

            // Hash individual signature for commit
            Hash256 sig_hash = SHA3::hash(signature);
            verified_sig_hashes.push_back(sig_hash);
            verified_bitmap.set(i);
            result.verified_count++;
        }

        std::cout << "[TEE Aggregator] Verified " << result.verified_count
                  << " / " << witness_signatures.size() << " signatures\n";

        // Check if we have enough verified signatures
        if (verified_sig_hashes.empty()) {
            result.failure_reason = "No signatures passed verification";
            result.aggregation_time_ms = getElapsedMs(start_time);
            return result;
        }

        // Step 2: Create aggregated commit
        // Concatenate all verified signature hashes in deterministic order
        std::vector<uint8_t> aggregate_input;
        aggregate_input.reserve(verified_sig_hashes.size() * 32);

        for (const auto& sig_hash : verified_sig_hashes) {
            aggregate_input.insert(aggregate_input.end(),
                                  sig_hash.begin(), sig_hash.end());
        }

        // Compute aggregate hash (TEE commit)
        Hash256 aggregate_hash = SHA3::hash(aggregate_input);

        // Step 3: Build TEE commit structure
        result.commit.aggregate_hash = aggregate_hash;
        result.commit.signature_hashes = verified_sig_hashes;
        result.commit.witness_count = result.verified_count;
        result.commit.witness_bitmap = verified_bitmap;
        result.commit.created_at = std::chrono::system_clock::now();

        result.success = true;
        result.aggregation_time_ms = getElapsedMs(start_time);

        std::cout << "[TEE Aggregator] ✓ Aggregation complete in "
                  << result.aggregation_time_ms << "ms\n";
        std::cout << "[TEE Aggregator]   Aggregate hash: "
                  << hashToHexString(aggregate_hash).substr(0, 16) << "...\n";

        return result;
    }

    /**
     * Verify TEE commit against block and signatures
     *
     * This verifies that the TEE commit matches the provided signatures
     * Used by validators to check block integrity
     *
     * @param commit TEE commit to verify
     * @param block_header Block header that was signed
     * @param witness_signatures Original witness signatures
     * @return True if commit is valid
     */
    bool verifyTEECommit(
            const TEECommit& commit,
            const BlockHeader& block_header,
            const std::vector<std::vector<uint8_t>>& witness_signatures) {

        std::cout << "[TEE Aggregator] Verifying TEE commit...\n";

        // Check witness count matches
        if (commit.witness_count != witness_signatures.size()) {
            std::cout << "[TEE Aggregator] ✗ Witness count mismatch: commit="
                      << commit.witness_count << ", actual="
                      << witness_signatures.size() << "\n";
            return false;
        }

        // Verify block header hash
        Hash256 header_hash = block_header.computeHeaderHash();
        if (commit.block_header_hash != header_hash) {
            std::cout << "[TEE Aggregator] ✗ Block header hash mismatch\n";
            return false;
        }

        // Recompute signature hashes
        std::vector<Hash256> recomputed_hashes;
        for (const auto& signature : witness_signatures) {
            Hash256 sig_hash = SHA3::hash(signature);
            recomputed_hashes.push_back(sig_hash);
        }

        // Verify signature hashes match commit
        if (recomputed_hashes.size() != commit.signature_hashes.size()) {
            std::cout << "[TEE Aggregator] ✗ Signature hash count mismatch\n";
            return false;
        }

        for (size_t i = 0; i < recomputed_hashes.size(); ++i) {
            if (recomputed_hashes[i] != commit.signature_hashes[i]) {
                std::cout << "[TEE Aggregator] ✗ Signature hash #" << i
                          << " mismatch\n";
                return false;
            }
        }

        // Recompute aggregate hash
        std::vector<uint8_t> aggregate_input;
        aggregate_input.reserve(commit.signature_hashes.size() * 32);

        for (const auto& sig_hash : commit.signature_hashes) {
            aggregate_input.insert(aggregate_input.end(),
                                  sig_hash.begin(), sig_hash.end());
        }

        Hash256 recomputed_aggregate = SHA3::hash(aggregate_input);

        if (recomputed_aggregate != commit.aggregate_hash) {
            std::cout << "[TEE Aggregator] ✗ Aggregate hash mismatch\n";
            return false;
        }

        std::cout << "[TEE Aggregator] ✓ TEE commit verified successfully\n";
        return true;
    }

private:
    /**
     * Verify FALCON-512 signature
     * Wrapper for signature verification
     */
    bool verifyFalconSignature(
            const Hash256& header_hash,
            const std::vector<uint8_t>& signature,
            const std::vector<uint8_t>& public_key) {

        // Convert hash to vector for verification
        std::vector<uint8_t> hash_vec(header_hash.begin(), header_hash.end());

        // Create temporary signer for verification
        FalconSigner verifier;

        // Verify signature
        return verifier.verify(hash_vec, signature, public_key);
    }

    /**
     * Convert hash to hex string for logging
     */
    std::string hashToHexString(const Hash256& hash) const {
        std::string result;
        result.reserve(64);
        for (uint8_t byte : hash) {
            char hex[3];
            snprintf(hex, sizeof(hex), "%02x", byte);
            result += hex;
        }
        return result;
    }

    /**
     * Get elapsed time in milliseconds
     */
    double getElapsedMs(
            const std::chrono::high_resolution_clock::time_point& start) const {
        auto now = std::chrono::high_resolution_clock::now();
        return std::chrono::duration<double, std::milli>(now - start).count();
    }
};

} // namespace crypto
} // namespace meshchain

#endif // MESHCHAIN_TEE_AGGREGATOR_H
